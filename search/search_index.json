{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction DriftPy is the Python client for the Drift protocol. It allows you to trade and fetch data from Drift using Python. Installation pip install driftpy Note: requires Python >= 3.9.","title":"Introduction"},{"location":"#introduction","text":"DriftPy is the Python client for the Drift protocol. It allows you to trade and fetch data from Drift using Python.","title":"Introduction"},{"location":"#installation","text":"pip install driftpy Note: requires Python >= 3.9.","title":"Installation"},{"location":"api_reference/","text":"API Reference clearing_house ClearingHouse This class is the main way to interact with Drift Protocol. It allows you to subscribe to the various accounts where the Market's state is stored, as well as: opening positions, liquidating, settling funding, depositing & withdrawing, and more. The default way to construct a ClearingHouse instance is using the create method. Source code in driftpy/clearing_house.py class ClearingHouse : \"\"\"This class is the main way to interact with Drift Protocol. It allows you to subscribe to the various accounts where the Market's state is stored, as well as: opening positions, liquidating, settling funding, depositing & withdrawing, and more. The default way to construct a ClearingHouse instance is using the [create][driftpy.clearing_house.ClearingHouse.create] method. \"\"\" def __init__ ( self , program : Program , pdas : ClearingHousePDAs ): \"\"\"Initialize the ClearingHouse object. Note: you probably want to use [create][driftpy.clearing_house.ClearingHouse.create] instead of this method. Args: program: The AnchorPy program object. pdas: The required PDAs for the ClearingHouse object. \"\"\" self . program = program self . pdas = pdas def _find_program_address ( self , seeds : list [ bytes ]) -> tuple [ PublicKey , int ]: return PublicKey . find_program_address ( seeds , self . program . program_id ) async def get_state_account ( self ) -> StateAccount : res = await _get_state_account ( self . program , self . pdas . state ) return cast ( StateAccount , res ) async def get_markets_account ( self ) -> MarketsAccount : res = await self . program . account [ \"Markets\" ] . fetch ( self . pdas . markets ) return cast ( MarketsAccount , res ) async def get_market ( self , market_index ) -> Market : market = ( await self . get_markets_account ()) . markets [ market_index ] return cast ( Market , market ) async def get_funding_payment_history_account ( self ) -> FundingPaymentHistoryAccount : res = await self . program . account [ \"FundingPaymentHistory\" ] . fetch ( self . pdas . funding_payment_history ) return cast ( FundingPaymentHistoryAccount , res ) async def get_funding_rate_history_account ( self ) -> FundingRateHistoryAccount : res = await self . program . account [ \"FundingRateHistory\" ] . fetch ( self . pdas . funding_rate_history ) return cast ( FundingRateHistoryAccount , res ) async def get_trade_history_account ( self ) -> TradeHistoryAccount : res = await self . program . account [ \"TradeHistory\" ] . fetch ( self . pdas . trade_history ) return cast ( TradeHistoryAccount , res ) async def get_liquidation_history_account ( self ) -> LiquidationHistoryAccount : res = await self . program . account [ \"LiquidationHistory\" ] . fetch ( self . pdas . liquidation_history ) return cast ( LiquidationHistoryAccount , res ) async def get_deposit_history_account ( self ) -> DepositHistoryAccount : res = await self . program . account [ \"DepositHistory\" ] . fetch ( self . pdas . deposit_history ) return cast ( DepositHistoryAccount , res ) async def get_curve_history_account ( self ) -> ExtendedCurveHistoryAccount : res = await self . program . account [ \"CurveHistory\" ] . fetch ( self . pdas . curve_history ) return cast ( ExtendedCurveHistoryAccount , res ) async def get_extended_curve_history_account ( self ) -> ExtendedCurveHistoryAccount : res = await self . program . account [ \"ExtendedCurveHistory\" ] . fetch ( self . pdas . extended_curve_history ) return cast ( ExtendedCurveHistoryAccount , res ) async def get_orders_state_account ( self ) -> OrderState : res = await self . program . account [ \"OrderState\" ] . fetch ( self . pdas . order_state ) return cast ( OrderState , res ) async def get_orders_history_account ( self ) -> OrderHistoryAccount : order_state = await self . get_orders_state_account () res = await self . program . account [ \"OrderHistory\" ] . fetch ( order_state . order_history ) return cast ( OrderHistoryAccount , res ) @staticmethod def _get_state_pubkey ( program : Program ) -> PublicKey : return PublicKey . find_program_address ([ b \"clearing_house\" ], program . program_id )[ 0 ] @classmethod async def create ( cls : Type [ T ], program : Program ) -> T : \"\"\"Create a new `ClearingHouse` instance. Args: program: An AnchorPy Program instance. Returns: The new `ClearingHouse` instance. \"\"\" state_pubkey = cls . _get_state_pubkey ( program ) state = await _get_state_account ( program , state_pubkey ) pdas = ClearingHousePDAs ( state = state_pubkey , markets = state . markets , trade_history = state . trade_history , deposit_history = state . deposit_history , funding_payment_history = state . funding_payment_history , funding_rate_history = state . funding_rate_history , liquidation_history = state . liquidation_history , curve_history = state . curve_history , extended_curve_history = state . extended_curve_history , order_state = state . order_state , ) return cls ( program , pdas ) @classmethod async def create_from_env ( cls : Type [ T ], env : str ) -> T : \"\"\"Create a new `ClearingHouse` instance. Args: program: An AnchorPy Program instance. Returns: The new `ClearingHouse` instance. \"\"\" program = load_program ( env ) state_pubkey = cls . _get_state_pubkey ( program ) state = await _get_state_account ( program , state_pubkey ) pdas = ClearingHousePDAs ( state = state_pubkey , markets = state . markets , trade_history = state . trade_history , deposit_history = state . deposit_history , funding_payment_history = state . funding_payment_history , funding_rate_history = state . funding_rate_history , liquidation_history = state . liquidation_history , curve_history = state . curve_history , order_state = state . order_state , extended_curve_history = state . extended_curve_history , ) return cls ( program , pdas ) def get_initialize_user_instructions ( self , ) -> tuple [ Keypair , PublicKey , TransactionInstruction ]: user_public_key , user_account_nonce = get_user_account_public_key_and_nonce ( self . program . program_id , self . program . provider . wallet . public_key ) remaining_accounts : list [ AccountMeta ] = [] optional_accounts = self . program . type [ \"InitializeUserOptionalAccounts\" ]( whitelist_token = False ) user_positions = Keypair () initialize_user_account_ix = self . program . instruction [ \"initialize_user\" ]( user_account_nonce , optional_accounts , ctx = Context ( accounts = { \"user\" : user_public_key , \"authority\" : self . program . provider . wallet . public_key , \"rent\" : SYSVAR_RENT_PUBKEY , \"system_program\" : SYS_PROGRAM_ID , \"user_positions\" : user_positions . public_key , \"state\" : self . pdas . state , }, remaining_accounts = remaining_accounts , ), ) return user_positions , user_public_key , initialize_user_account_ix async def get_deposit_collateral_ix ( self , amount : int , collateral_account_public_key : PublicKey , user_positions_account_public_key : Optional [ PublicKey ] = None , state : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () if user_positions_account_public_key is None : user_account = await self . get_user_account () user_positions_account_public_key = user_account . positions state_to_use = await self . get_state_account () if state is None else state return self . program . instruction [ \"deposit_collateral\" ]( amount , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"collateral_vault\" : state_to_use . collateral_vault , \"user_collateral_account\" : collateral_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"token_program\" : TOKEN_PROGRAM_ID , \"markets\" : state_to_use . markets , \"funding_payment_history\" : state_to_use . funding_payment_history , \"deposit_history\" : state_to_use . deposit_history , \"user_positions\" : user_positions_account_public_key , }, ), ) async def deposit_collateral ( self , amount : int , collateral_account_public_key : PublicKey , user_positions_account_public_key : Optional [ PublicKey ] = None , state : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_deposit_collateral_ix ( amount , collateral_account_public_key , user_positions_account_public_key , state , ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def initialize_user_account_and_deposit_collateral ( self , amount : int , collateral_account_public_key : PublicKey , state : Optional [ StateAccount ] = None , ) -> tuple [ TransactionSignature , PublicKey ]: \"\"\"Creates the Clearing House User account for a user, and deposits some initial collateral.\"\"\" # noqa: E501 ( user_positions_account , user_account_public_key , initialize_user_account_ix , ) = self . get_initialize_user_instructions () deposit_collateral_ix = await self . get_deposit_collateral_ix ( amount , collateral_account_public_key , user_positions_account . public_key , state , ) tx = Transaction () . add ( initialize_user_account_ix , deposit_collateral_ix ) tx_sig = await self . program . provider . send ( tx , [ user_positions_account ]) return tx_sig , user_account_public_key def get_user_account_public_key ( self ) -> PublicKey : \"\"\"Get the address for the Clearing House User's account. NOT the user's wallet address. \"\"\" return get_user_account_public_key_and_nonce ( self . program . program_id , self . program . provider . wallet . public_key )[ 0 ] def get_user_orders_public_key ( self ) -> PublicKey : \"\"\"Get the address for the Clearing House User's order account. NOT the user's wallet address. \"\"\" return get_user_orders_account_public_key_and_nonce ( self . program . program_id , self . program . provider . wallet . public_key )[ 0 ] def get_order_state_public_key ( self ) -> PublicKey : \"\"\"Get the address for the Clearing House Order State account.\"\"\" return get_order_state_account_public_key_and_nonce ( self . program . program_id )[ 0 ] async def get_withdraw_collateral_ix ( self , amount : int , collateral_account_public_key : PublicKey , user_account : Optional [ User ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user = ( cast ( User , await self . program . account [ \"User\" ] . fetch ( user_account_public_key ) ) if user_account is None else user_account ) state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"withdraw_collateral\" ]( amount , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"collateral_vault\" : state . collateral_vault , \"collateral_vault_authority\" : state . collateral_vault_authority , \"insurance_vault\" : state . insurance_vault , \"insurance_vault_authority\" : state . insurance_vault_authority , \"user_collateral_account\" : collateral_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"token_program\" : TOKEN_PROGRAM_ID , \"markets\" : state . markets , \"user_positions\" : user . positions , \"funding_payment_history\" : state . funding_payment_history , \"deposit_history\" : state . deposit_history , }, ), ) async def withdraw_collateral ( self , amount : int , collateral_account_public_key : PublicKey , user : Optional [ User ] = None , state : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_withdraw_collateral_ix ( amount , collateral_account_public_key , user , state ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def open_position ( self , direction : PositionDirection , amount : int , market_index : int , limit_price : Optional [ int ] = None , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , ) -> TransactionSignature : ix = await self . get_open_position_ix ( direction , amount , market_index , limit_price , discount_token , referrer ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_open_position_ix ( self , direction : PositionDirection , amount : int , market_index : int , limit_price : Optional [ int ] = None , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) limit_price_to_use = 0 if limit_price is None else limit_price optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ market_index ] . amm . oracle state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"open_position\" ]( direction , amount , market_index , limit_price_to_use , optional_accounts , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_positions\" : user_account_to_use . positions , \"trade_history\" : state . trade_history , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), ) async def place_order ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , ) -> TransactionSignature : ix = await self . get_place_order_ix ( order_params , discount_token , referrer ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_place_order_ix ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , orders_state_account : Optional [ OrderState ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ order_params . market_index ] . amm . oracle state = ( await self . get_state_account () if state_account is None else state_account ) orders_state = ( await self . get_orders_state_account () if orders_state_account is None else orders_state_account ) return self . program . instruction [ \"place_order\" ]( order_params , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_orders\" : self . get_user_orders_public_key (), \"user_positions\" : user_account_to_use . positions , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"order_state\" : self . get_order_state_public_key (), \"order_history\" : orders_state . order_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), ) async def place_and_fill_order ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , ) -> TransactionSignature : ix = await self . get_place_and_fill_order_ix ( order_params , discount_token , referrer ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_place_and_fill_order_ix ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , orders_state_account : Optional [ OrderState ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ order_params . market_index ] . amm . oracle state = ( await self . get_state_account () if state_account is None else state_account ) orders_state = ( await self . get_orders_state_account () if orders_state_account is None else orders_state_account ) return self . program . instruction [ \"place_and_fill_order\" ]( order_params , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_orders\" : self . get_user_orders_public_key (), \"user_positions\" : user_account_to_use . positions , \"trade_history\" : state . trade_history , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"order_state\" : self . get_order_state_public_key (), \"order_history\" : orders_state . order_history , \"extended_curve_history\" : state . extended_curve_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), ) async def cancel_order ( self , order_id : int , ) -> TransactionSignature : ix = await self . get_cancel_order_ix ( order_id ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_cancel_order_ix ( self , order_id : int , user_account : Optional [ User ] = None , state_account : Optional [ StateAccount ] = None , orders_state_account : Optional [ OrderState ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) state = ( await self . get_state_account () if state_account is None else state_account ) orders_state = ( await self . get_orders_state_account () if orders_state_account is None else orders_state_account ) return self . program . instruction [ \"cancel_order\" ]( order_id , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_orders\" : self . get_user_orders_public_key (), \"user_positions\" : user_account_to_use . positions , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"order_state\" : self . get_order_state_public_key (), \"order_history\" : orders_state . order_history , }, ), ) async def get_user_account ( self ) -> User : user_account_pubkey = self . get_user_account_public_key () return cast ( User , await self . program . account [ \"User\" ] . fetch ( user_account_pubkey )) async def get_close_position_ix ( self , market_index : int , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ market_index ] . amm . oracle optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token is not None : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer is not None : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"close_position\" ]( market_index , optional_accounts , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_positions\" : user_account_to_use . positions , \"trade_history\" : state . trade_history , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), ) async def close_position ( self , market_index : int , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : \"\"\"Close an entire position. If you want to reduce a position, use the [open_position][driftpy.clearing_house.ClearingHouse.open_position] method in the opposite direction of the current position.\"\"\" # noqa: E501 ix = await self . get_close_position_ix ( market_index = market_index , discount_token = discount_token , referrer = referrer , user_account = user_account , markets_account = markets_account , state_account = state_account , ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def delete_user ( self ) -> TransactionSignature : user_account_public_key = self . get_user_account_public_key () user = await self . program . account [ \"User\" ] . fetch ( user_account_public_key ) return await self . program . rpc [ \"DeleteUser\" ]( ctx = Context ( accounts = { \"user\" : user_account_public_key , \"user_positions\" : user . positions , \"authority\" : self . program . provider . wallet . public_key , } ) ) async def liquidate ( self , liquidatee_user_account_public_key : PublicKey , liquidatee_user_account : Optional [ User ] = None , liquidatee_positions : Optional [ UserPositions ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_liquidate_ix ( liquidatee_user_account_public_key , liquidatee_user_account = liquidatee_user_account , liquidatee_positions = liquidatee_positions , markets_account = markets_account , state_account = state_account , ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_liquidate_ix ( self , liquidatee_user_account_public_key : PublicKey , liquidatee_user_account : Optional [ User ] = None , liquidatee_positions : Optional [ UserPositions ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () liquidatee_user_account_to_use = ( cast ( User , await self . program . account [ \"User\" ] . fetch ( liquidatee_user_account_public_key ), ) if liquidatee_user_account is None else liquidatee_user_account ) liquidatee_positions_to_use = ( cast ( UserPositions , await self . program . account [ \"UserPositions\" ] . fetch ( liquidatee_user_account_to_use . positions ), ) if liquidatee_positions is None else liquidatee_positions ) markets = ( await self . get_markets_account () if markets_account is None else markets_account ) remaining_accounts = [] for position in liquidatee_positions_to_use . positions : if position . base_asset_amount != 0 : market = markets . markets [ position . market_index ] remaining_accounts . append ( AccountMeta ( pubkey = market . amm . oracle , is_writable = False , is_signer = False , ) ) state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"liquidate\" ]( ctx = Context ( accounts = { \"state\" : self . pdas . state , \"authority\" : self . program . provider . wallet . public_key , \"user\" : liquidatee_user_account_public_key , \"liquidator\" : user_account_public_key , \"collateral_vault\" : state . collateral_vault , \"collateral_vault_authority\" : state . collateral_vault_authority , \"insurance_vault\" : state . insurance_vault , \"insurance_vault_authority\" : state . insurance_vault_authority , \"token_program\" : TOKEN_PROGRAM_ID , \"markets\" : state . markets , \"user_positions\" : liquidatee_user_account_to_use . positions , \"trade_history\" : state . trade_history , \"liquidation_history\" : state . liquidation_history , \"funding_payment_history\" : state . funding_payment_history , }, remaining_accounts = remaining_accounts , ) ) async def update_funding_rate ( self , oracle : PublicKey , market_index : int , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_update_funding_rate_ix ( oracle , market_index , state_account ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_update_funding_rate_ix ( self , oracle : PublicKey , market_index : int , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"update_funding_rate\" ]( market_index , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"markets\" : state . markets , \"oracle\" : oracle , \"funding_rate_history\" : state . funding_rate_history , }, ), ) async def settle_funding_payment ( self , user_account : PublicKey , user_positions_account : PublicKey , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_settle_funding_payment_ix ( user_account , user_positions_account ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_settle_funding_payment_ix ( self , user_account : PublicKey , user_positions_account : PublicKey , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"settle_funding_payment\" ]( ctx = Context ( accounts = { \"state\" : self . pdas . state , \"markets\" : state . markets , \"user\" : user_account , \"user_positions\" : user_positions_account , \"funding_payment_history\" : state . funding_payment_history , }, ) ) @staticmethod def local_idl () -> Idl : \"\"\"Load the `clearing_house` IDL embedded in the Python package.\"\"\" with resources . open_text ( \"driftpy.idl\" , \"clearing_house.json\" ) as f : idl_raw = json . load ( f ) return Idl . from_json ( idl_raw ) __init__ ( self , program , pdas ) special Initialize the ClearingHouse object. Note: you probably want to use create instead of this method. Parameters: Name Type Description Default program Program The AnchorPy program object. required pdas ClearingHousePDAs The required PDAs for the ClearingHouse object. required Source code in driftpy/clearing_house.py def __init__ ( self , program : Program , pdas : ClearingHousePDAs ): \"\"\"Initialize the ClearingHouse object. Note: you probably want to use [create][driftpy.clearing_house.ClearingHouse.create] instead of this method. Args: program: The AnchorPy program object. pdas: The required PDAs for the ClearingHouse object. \"\"\" self . program = program self . pdas = pdas cancel_order ( self , order_id ) async Source code in driftpy/clearing_house.py async def cancel_order ( self , order_id : int , ) -> TransactionSignature : ix = await self . get_cancel_order_ix ( order_id ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) close_position ( self , market_index , discount_token = None , referrer = None , user_account = None , markets_account = None , state_account = None ) async Close an entire position. If you want to reduce a position, use the open_position method in the opposite direction of the current position. Source code in driftpy/clearing_house.py async def close_position ( self , market_index : int , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : \"\"\"Close an entire position. If you want to reduce a position, use the [open_position][driftpy.clearing_house.ClearingHouse.open_position] method in the opposite direction of the current position.\"\"\" # noqa: E501 ix = await self . get_close_position_ix ( market_index = market_index , discount_token = discount_token , referrer = referrer , user_account = user_account , markets_account = markets_account , state_account = state_account , ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) create ( program ) async classmethod Create a new ClearingHouse instance. Parameters: Name Type Description Default program Program An AnchorPy Program instance. required Returns: Type Description ~T The new ClearingHouse instance. Source code in driftpy/clearing_house.py @classmethod async def create ( cls : Type [ T ], program : Program ) -> T : \"\"\"Create a new `ClearingHouse` instance. Args: program: An AnchorPy Program instance. Returns: The new `ClearingHouse` instance. \"\"\" state_pubkey = cls . _get_state_pubkey ( program ) state = await _get_state_account ( program , state_pubkey ) pdas = ClearingHousePDAs ( state = state_pubkey , markets = state . markets , trade_history = state . trade_history , deposit_history = state . deposit_history , funding_payment_history = state . funding_payment_history , funding_rate_history = state . funding_rate_history , liquidation_history = state . liquidation_history , curve_history = state . curve_history , extended_curve_history = state . extended_curve_history , order_state = state . order_state , ) return cls ( program , pdas ) create_from_env ( env ) async classmethod Create a new ClearingHouse instance. Parameters: Name Type Description Default program An AnchorPy Program instance. required Returns: Type Description ~T The new ClearingHouse instance. Source code in driftpy/clearing_house.py @classmethod async def create_from_env ( cls : Type [ T ], env : str ) -> T : \"\"\"Create a new `ClearingHouse` instance. Args: program: An AnchorPy Program instance. Returns: The new `ClearingHouse` instance. \"\"\" program = load_program ( env ) state_pubkey = cls . _get_state_pubkey ( program ) state = await _get_state_account ( program , state_pubkey ) pdas = ClearingHousePDAs ( state = state_pubkey , markets = state . markets , trade_history = state . trade_history , deposit_history = state . deposit_history , funding_payment_history = state . funding_payment_history , funding_rate_history = state . funding_rate_history , liquidation_history = state . liquidation_history , curve_history = state . curve_history , order_state = state . order_state , extended_curve_history = state . extended_curve_history , ) return cls ( program , pdas ) delete_user ( self ) async Source code in driftpy/clearing_house.py async def delete_user ( self ) -> TransactionSignature : user_account_public_key = self . get_user_account_public_key () user = await self . program . account [ \"User\" ] . fetch ( user_account_public_key ) return await self . program . rpc [ \"DeleteUser\" ]( ctx = Context ( accounts = { \"user\" : user_account_public_key , \"user_positions\" : user . positions , \"authority\" : self . program . provider . wallet . public_key , } ) ) deposit_collateral ( self , amount , collateral_account_public_key , user_positions_account_public_key = None , state = None ) async Source code in driftpy/clearing_house.py async def deposit_collateral ( self , amount : int , collateral_account_public_key : PublicKey , user_positions_account_public_key : Optional [ PublicKey ] = None , state : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_deposit_collateral_ix ( amount , collateral_account_public_key , user_positions_account_public_key , state , ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) get_cancel_order_ix ( self , order_id , user_account = None , state_account = None , orders_state_account = None ) async Source code in driftpy/clearing_house.py async def get_cancel_order_ix ( self , order_id : int , user_account : Optional [ User ] = None , state_account : Optional [ StateAccount ] = None , orders_state_account : Optional [ OrderState ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) state = ( await self . get_state_account () if state_account is None else state_account ) orders_state = ( await self . get_orders_state_account () if orders_state_account is None else orders_state_account ) return self . program . instruction [ \"cancel_order\" ]( order_id , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_orders\" : self . get_user_orders_public_key (), \"user_positions\" : user_account_to_use . positions , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"order_state\" : self . get_order_state_public_key (), \"order_history\" : orders_state . order_history , }, ), ) get_close_position_ix ( self , market_index , discount_token = None , referrer = None , user_account = None , markets_account = None , state_account = None ) async Source code in driftpy/clearing_house.py async def get_close_position_ix ( self , market_index : int , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ market_index ] . amm . oracle optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token is not None : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer is not None : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"close_position\" ]( market_index , optional_accounts , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_positions\" : user_account_to_use . positions , \"trade_history\" : state . trade_history , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), ) get_curve_history_account ( self ) async Source code in driftpy/clearing_house.py async def get_curve_history_account ( self ) -> ExtendedCurveHistoryAccount : res = await self . program . account [ \"CurveHistory\" ] . fetch ( self . pdas . curve_history ) return cast ( ExtendedCurveHistoryAccount , res ) get_deposit_collateral_ix ( self , amount , collateral_account_public_key , user_positions_account_public_key = None , state = None ) async Source code in driftpy/clearing_house.py async def get_deposit_collateral_ix ( self , amount : int , collateral_account_public_key : PublicKey , user_positions_account_public_key : Optional [ PublicKey ] = None , state : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () if user_positions_account_public_key is None : user_account = await self . get_user_account () user_positions_account_public_key = user_account . positions state_to_use = await self . get_state_account () if state is None else state return self . program . instruction [ \"deposit_collateral\" ]( amount , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"collateral_vault\" : state_to_use . collateral_vault , \"user_collateral_account\" : collateral_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"token_program\" : TOKEN_PROGRAM_ID , \"markets\" : state_to_use . markets , \"funding_payment_history\" : state_to_use . funding_payment_history , \"deposit_history\" : state_to_use . deposit_history , \"user_positions\" : user_positions_account_public_key , }, ), ) get_deposit_history_account ( self ) async Source code in driftpy/clearing_house.py async def get_deposit_history_account ( self ) -> DepositHistoryAccount : res = await self . program . account [ \"DepositHistory\" ] . fetch ( self . pdas . deposit_history ) return cast ( DepositHistoryAccount , res ) get_extended_curve_history_account ( self ) async Source code in driftpy/clearing_house.py async def get_extended_curve_history_account ( self ) -> ExtendedCurveHistoryAccount : res = await self . program . account [ \"ExtendedCurveHistory\" ] . fetch ( self . pdas . extended_curve_history ) return cast ( ExtendedCurveHistoryAccount , res ) get_funding_payment_history_account ( self ) async Source code in driftpy/clearing_house.py async def get_funding_payment_history_account ( self ) -> FundingPaymentHistoryAccount : res = await self . program . account [ \"FundingPaymentHistory\" ] . fetch ( self . pdas . funding_payment_history ) return cast ( FundingPaymentHistoryAccount , res ) get_funding_rate_history_account ( self ) async Source code in driftpy/clearing_house.py async def get_funding_rate_history_account ( self ) -> FundingRateHistoryAccount : res = await self . program . account [ \"FundingRateHistory\" ] . fetch ( self . pdas . funding_rate_history ) return cast ( FundingRateHistoryAccount , res ) get_initialize_user_instructions ( self ) Source code in driftpy/clearing_house.py def get_initialize_user_instructions ( self , ) -> tuple [ Keypair , PublicKey , TransactionInstruction ]: user_public_key , user_account_nonce = get_user_account_public_key_and_nonce ( self . program . program_id , self . program . provider . wallet . public_key ) remaining_accounts : list [ AccountMeta ] = [] optional_accounts = self . program . type [ \"InitializeUserOptionalAccounts\" ]( whitelist_token = False ) user_positions = Keypair () initialize_user_account_ix = self . program . instruction [ \"initialize_user\" ]( user_account_nonce , optional_accounts , ctx = Context ( accounts = { \"user\" : user_public_key , \"authority\" : self . program . provider . wallet . public_key , \"rent\" : SYSVAR_RENT_PUBKEY , \"system_program\" : SYS_PROGRAM_ID , \"user_positions\" : user_positions . public_key , \"state\" : self . pdas . state , }, remaining_accounts = remaining_accounts , ), ) return user_positions , user_public_key , initialize_user_account_ix get_liquidate_ix ( self , liquidatee_user_account_public_key , liquidatee_user_account = None , liquidatee_positions = None , markets_account = None , state_account = None ) async Source code in driftpy/clearing_house.py async def get_liquidate_ix ( self , liquidatee_user_account_public_key : PublicKey , liquidatee_user_account : Optional [ User ] = None , liquidatee_positions : Optional [ UserPositions ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () liquidatee_user_account_to_use = ( cast ( User , await self . program . account [ \"User\" ] . fetch ( liquidatee_user_account_public_key ), ) if liquidatee_user_account is None else liquidatee_user_account ) liquidatee_positions_to_use = ( cast ( UserPositions , await self . program . account [ \"UserPositions\" ] . fetch ( liquidatee_user_account_to_use . positions ), ) if liquidatee_positions is None else liquidatee_positions ) markets = ( await self . get_markets_account () if markets_account is None else markets_account ) remaining_accounts = [] for position in liquidatee_positions_to_use . positions : if position . base_asset_amount != 0 : market = markets . markets [ position . market_index ] remaining_accounts . append ( AccountMeta ( pubkey = market . amm . oracle , is_writable = False , is_signer = False , ) ) state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"liquidate\" ]( ctx = Context ( accounts = { \"state\" : self . pdas . state , \"authority\" : self . program . provider . wallet . public_key , \"user\" : liquidatee_user_account_public_key , \"liquidator\" : user_account_public_key , \"collateral_vault\" : state . collateral_vault , \"collateral_vault_authority\" : state . collateral_vault_authority , \"insurance_vault\" : state . insurance_vault , \"insurance_vault_authority\" : state . insurance_vault_authority , \"token_program\" : TOKEN_PROGRAM_ID , \"markets\" : state . markets , \"user_positions\" : liquidatee_user_account_to_use . positions , \"trade_history\" : state . trade_history , \"liquidation_history\" : state . liquidation_history , \"funding_payment_history\" : state . funding_payment_history , }, remaining_accounts = remaining_accounts , ) ) get_liquidation_history_account ( self ) async Source code in driftpy/clearing_house.py async def get_liquidation_history_account ( self ) -> LiquidationHistoryAccount : res = await self . program . account [ \"LiquidationHistory\" ] . fetch ( self . pdas . liquidation_history ) return cast ( LiquidationHistoryAccount , res ) get_market ( self , market_index ) async Source code in driftpy/clearing_house.py async def get_market ( self , market_index ) -> Market : market = ( await self . get_markets_account ()) . markets [ market_index ] return cast ( Market , market ) get_markets_account ( self ) async Source code in driftpy/clearing_house.py async def get_markets_account ( self ) -> MarketsAccount : res = await self . program . account [ \"Markets\" ] . fetch ( self . pdas . markets ) return cast ( MarketsAccount , res ) get_open_position_ix ( self , direction , amount , market_index , limit_price = None , discount_token = None , referrer = None , user_account = None , markets_account = None , state_account = None ) async Source code in driftpy/clearing_house.py async def get_open_position_ix ( self , direction : PositionDirection , amount : int , market_index : int , limit_price : Optional [ int ] = None , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) limit_price_to_use = 0 if limit_price is None else limit_price optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ market_index ] . amm . oracle state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"open_position\" ]( direction , amount , market_index , limit_price_to_use , optional_accounts , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_positions\" : user_account_to_use . positions , \"trade_history\" : state . trade_history , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), ) get_order_state_public_key ( self ) Get the address for the Clearing House Order State account. Source code in driftpy/clearing_house.py def get_order_state_public_key ( self ) -> PublicKey : \"\"\"Get the address for the Clearing House Order State account.\"\"\" return get_order_state_account_public_key_and_nonce ( self . program . program_id )[ 0 ] get_orders_history_account ( self ) async Source code in driftpy/clearing_house.py async def get_orders_history_account ( self ) -> OrderHistoryAccount : order_state = await self . get_orders_state_account () res = await self . program . account [ \"OrderHistory\" ] . fetch ( order_state . order_history ) return cast ( OrderHistoryAccount , res ) get_orders_state_account ( self ) async Source code in driftpy/clearing_house.py async def get_orders_state_account ( self ) -> OrderState : res = await self . program . account [ \"OrderState\" ] . fetch ( self . pdas . order_state ) return cast ( OrderState , res ) get_place_and_fill_order_ix ( self , order_params , discount_token = None , referrer = None , user_account = None , markets_account = None , state_account = None , orders_state_account = None ) async Source code in driftpy/clearing_house.py async def get_place_and_fill_order_ix ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , orders_state_account : Optional [ OrderState ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ order_params . market_index ] . amm . oracle state = ( await self . get_state_account () if state_account is None else state_account ) orders_state = ( await self . get_orders_state_account () if orders_state_account is None else orders_state_account ) return self . program . instruction [ \"place_and_fill_order\" ]( order_params , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_orders\" : self . get_user_orders_public_key (), \"user_positions\" : user_account_to_use . positions , \"trade_history\" : state . trade_history , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"order_state\" : self . get_order_state_public_key (), \"order_history\" : orders_state . order_history , \"extended_curve_history\" : state . extended_curve_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), ) get_place_order_ix ( self , order_params , discount_token = None , referrer = None , user_account = None , markets_account = None , state_account = None , orders_state_account = None ) async Source code in driftpy/clearing_house.py async def get_place_order_ix ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , orders_state_account : Optional [ OrderState ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ order_params . market_index ] . amm . oracle state = ( await self . get_state_account () if state_account is None else state_account ) orders_state = ( await self . get_orders_state_account () if orders_state_account is None else orders_state_account ) return self . program . instruction [ \"place_order\" ]( order_params , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_orders\" : self . get_user_orders_public_key (), \"user_positions\" : user_account_to_use . positions , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"order_state\" : self . get_order_state_public_key (), \"order_history\" : orders_state . order_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), ) get_settle_funding_payment_ix ( self , user_account , user_positions_account , state_account = None ) async Source code in driftpy/clearing_house.py async def get_settle_funding_payment_ix ( self , user_account : PublicKey , user_positions_account : PublicKey , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"settle_funding_payment\" ]( ctx = Context ( accounts = { \"state\" : self . pdas . state , \"markets\" : state . markets , \"user\" : user_account , \"user_positions\" : user_positions_account , \"funding_payment_history\" : state . funding_payment_history , }, ) ) get_state_account ( self ) async Source code in driftpy/clearing_house.py async def get_state_account ( self ) -> StateAccount : res = await _get_state_account ( self . program , self . pdas . state ) return cast ( StateAccount , res ) get_trade_history_account ( self ) async Source code in driftpy/clearing_house.py async def get_trade_history_account ( self ) -> TradeHistoryAccount : res = await self . program . account [ \"TradeHistory\" ] . fetch ( self . pdas . trade_history ) return cast ( TradeHistoryAccount , res ) get_update_funding_rate_ix ( self , oracle , market_index , state_account = None ) async Source code in driftpy/clearing_house.py async def get_update_funding_rate_ix ( self , oracle : PublicKey , market_index : int , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"update_funding_rate\" ]( market_index , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"markets\" : state . markets , \"oracle\" : oracle , \"funding_rate_history\" : state . funding_rate_history , }, ), ) get_user_account ( self ) async Source code in driftpy/clearing_house.py async def get_user_account ( self ) -> User : user_account_pubkey = self . get_user_account_public_key () return cast ( User , await self . program . account [ \"User\" ] . fetch ( user_account_pubkey )) get_user_account_public_key ( self ) Get the address for the Clearing House User's account. NOT the user's wallet address. Source code in driftpy/clearing_house.py def get_user_account_public_key ( self ) -> PublicKey : \"\"\"Get the address for the Clearing House User's account. NOT the user's wallet address. \"\"\" return get_user_account_public_key_and_nonce ( self . program . program_id , self . program . provider . wallet . public_key )[ 0 ] get_user_orders_public_key ( self ) Get the address for the Clearing House User's order account. NOT the user's wallet address. Source code in driftpy/clearing_house.py def get_user_orders_public_key ( self ) -> PublicKey : \"\"\"Get the address for the Clearing House User's order account. NOT the user's wallet address. \"\"\" return get_user_orders_account_public_key_and_nonce ( self . program . program_id , self . program . provider . wallet . public_key )[ 0 ] get_withdraw_collateral_ix ( self , amount , collateral_account_public_key , user_account = None , state_account = None ) async Source code in driftpy/clearing_house.py async def get_withdraw_collateral_ix ( self , amount : int , collateral_account_public_key : PublicKey , user_account : Optional [ User ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user = ( cast ( User , await self . program . account [ \"User\" ] . fetch ( user_account_public_key ) ) if user_account is None else user_account ) state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"withdraw_collateral\" ]( amount , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"collateral_vault\" : state . collateral_vault , \"collateral_vault_authority\" : state . collateral_vault_authority , \"insurance_vault\" : state . insurance_vault , \"insurance_vault_authority\" : state . insurance_vault_authority , \"user_collateral_account\" : collateral_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"token_program\" : TOKEN_PROGRAM_ID , \"markets\" : state . markets , \"user_positions\" : user . positions , \"funding_payment_history\" : state . funding_payment_history , \"deposit_history\" : state . deposit_history , }, ), ) initialize_user_account_and_deposit_collateral ( self , amount , collateral_account_public_key , state = None ) async Creates the Clearing House User account for a user, and deposits some initial collateral. Source code in driftpy/clearing_house.py async def initialize_user_account_and_deposit_collateral ( self , amount : int , collateral_account_public_key : PublicKey , state : Optional [ StateAccount ] = None , ) -> tuple [ TransactionSignature , PublicKey ]: \"\"\"Creates the Clearing House User account for a user, and deposits some initial collateral.\"\"\" # noqa: E501 ( user_positions_account , user_account_public_key , initialize_user_account_ix , ) = self . get_initialize_user_instructions () deposit_collateral_ix = await self . get_deposit_collateral_ix ( amount , collateral_account_public_key , user_positions_account . public_key , state , ) tx = Transaction () . add ( initialize_user_account_ix , deposit_collateral_ix ) tx_sig = await self . program . provider . send ( tx , [ user_positions_account ]) return tx_sig , user_account_public_key liquidate ( self , liquidatee_user_account_public_key , liquidatee_user_account = None , liquidatee_positions = None , markets_account = None , state_account = None ) async Source code in driftpy/clearing_house.py async def liquidate ( self , liquidatee_user_account_public_key : PublicKey , liquidatee_user_account : Optional [ User ] = None , liquidatee_positions : Optional [ UserPositions ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_liquidate_ix ( liquidatee_user_account_public_key , liquidatee_user_account = liquidatee_user_account , liquidatee_positions = liquidatee_positions , markets_account = markets_account , state_account = state_account , ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) local_idl () staticmethod Load the clearing_house IDL embedded in the Python package. Source code in driftpy/clearing_house.py @staticmethod def local_idl () -> Idl : \"\"\"Load the `clearing_house` IDL embedded in the Python package.\"\"\" with resources . open_text ( \"driftpy.idl\" , \"clearing_house.json\" ) as f : idl_raw = json . load ( f ) return Idl . from_json ( idl_raw ) open_position ( self , direction , amount , market_index , limit_price = None , discount_token = None , referrer = None ) async Source code in driftpy/clearing_house.py async def open_position ( self , direction : PositionDirection , amount : int , market_index : int , limit_price : Optional [ int ] = None , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , ) -> TransactionSignature : ix = await self . get_open_position_ix ( direction , amount , market_index , limit_price , discount_token , referrer ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) place_and_fill_order ( self , order_params , discount_token = None , referrer = None ) async Source code in driftpy/clearing_house.py async def place_and_fill_order ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , ) -> TransactionSignature : ix = await self . get_place_and_fill_order_ix ( order_params , discount_token , referrer ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) place_order ( self , order_params , discount_token = None , referrer = None ) async Source code in driftpy/clearing_house.py async def place_order ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , ) -> TransactionSignature : ix = await self . get_place_order_ix ( order_params , discount_token , referrer ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) settle_funding_payment ( self , user_account , user_positions_account , state_account = None ) async Source code in driftpy/clearing_house.py async def settle_funding_payment ( self , user_account : PublicKey , user_positions_account : PublicKey , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_settle_funding_payment_ix ( user_account , user_positions_account ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) update_funding_rate ( self , oracle , market_index , state_account = None ) async Source code in driftpy/clearing_house.py async def update_funding_rate ( self , oracle : PublicKey , market_index : int , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_update_funding_rate_ix ( oracle , market_index , state_account ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) withdraw_collateral ( self , amount , collateral_account_public_key , user = None , state = None ) async Source code in driftpy/clearing_house.py async def withdraw_collateral ( self , amount : int , collateral_account_public_key : PublicKey , user : Optional [ User ] = None , state : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_withdraw_collateral_ix ( amount , collateral_account_public_key , user , state ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) ClearingHousePDAs dataclass A collection of pubkeys needed to instantiate ClearingHouse Source code in driftpy/clearing_house.py @dataclass class ClearingHousePDAs : \"\"\"A collection of pubkeys needed to instantiate [ClearingHouse][driftpy.clearing_house.ClearingHouse]\"\"\" state : PublicKey markets : PublicKey trade_history : PublicKey deposit_history : PublicKey funding_payment_history : PublicKey funding_rate_history : PublicKey liquidation_history : PublicKey curve_history : PublicKey extended_curve_history : PublicKey order_state : PublicKey curve_history : PublicKey dataclass-field deposit_history : PublicKey dataclass-field extended_curve_history : PublicKey dataclass-field funding_payment_history : PublicKey dataclass-field funding_rate_history : PublicKey dataclass-field liquidation_history : PublicKey dataclass-field markets : PublicKey dataclass-field order_state : PublicKey dataclass-field state : PublicKey dataclass-field trade_history : PublicKey dataclass-field __init__ ( self , state , markets , trade_history , deposit_history , funding_payment_history , funding_rate_history , liquidation_history , curve_history , extended_curve_history , order_state ) special","title":"API Reference"},{"location":"api_reference/#api-reference","text":"","title":"API Reference"},{"location":"api_reference/#driftpy.clearing_house","text":"","title":"clearing_house"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse","text":"This class is the main way to interact with Drift Protocol. It allows you to subscribe to the various accounts where the Market's state is stored, as well as: opening positions, liquidating, settling funding, depositing & withdrawing, and more. The default way to construct a ClearingHouse instance is using the create method. Source code in driftpy/clearing_house.py class ClearingHouse : \"\"\"This class is the main way to interact with Drift Protocol. It allows you to subscribe to the various accounts where the Market's state is stored, as well as: opening positions, liquidating, settling funding, depositing & withdrawing, and more. The default way to construct a ClearingHouse instance is using the [create][driftpy.clearing_house.ClearingHouse.create] method. \"\"\" def __init__ ( self , program : Program , pdas : ClearingHousePDAs ): \"\"\"Initialize the ClearingHouse object. Note: you probably want to use [create][driftpy.clearing_house.ClearingHouse.create] instead of this method. Args: program: The AnchorPy program object. pdas: The required PDAs for the ClearingHouse object. \"\"\" self . program = program self . pdas = pdas def _find_program_address ( self , seeds : list [ bytes ]) -> tuple [ PublicKey , int ]: return PublicKey . find_program_address ( seeds , self . program . program_id ) async def get_state_account ( self ) -> StateAccount : res = await _get_state_account ( self . program , self . pdas . state ) return cast ( StateAccount , res ) async def get_markets_account ( self ) -> MarketsAccount : res = await self . program . account [ \"Markets\" ] . fetch ( self . pdas . markets ) return cast ( MarketsAccount , res ) async def get_market ( self , market_index ) -> Market : market = ( await self . get_markets_account ()) . markets [ market_index ] return cast ( Market , market ) async def get_funding_payment_history_account ( self ) -> FundingPaymentHistoryAccount : res = await self . program . account [ \"FundingPaymentHistory\" ] . fetch ( self . pdas . funding_payment_history ) return cast ( FundingPaymentHistoryAccount , res ) async def get_funding_rate_history_account ( self ) -> FundingRateHistoryAccount : res = await self . program . account [ \"FundingRateHistory\" ] . fetch ( self . pdas . funding_rate_history ) return cast ( FundingRateHistoryAccount , res ) async def get_trade_history_account ( self ) -> TradeHistoryAccount : res = await self . program . account [ \"TradeHistory\" ] . fetch ( self . pdas . trade_history ) return cast ( TradeHistoryAccount , res ) async def get_liquidation_history_account ( self ) -> LiquidationHistoryAccount : res = await self . program . account [ \"LiquidationHistory\" ] . fetch ( self . pdas . liquidation_history ) return cast ( LiquidationHistoryAccount , res ) async def get_deposit_history_account ( self ) -> DepositHistoryAccount : res = await self . program . account [ \"DepositHistory\" ] . fetch ( self . pdas . deposit_history ) return cast ( DepositHistoryAccount , res ) async def get_curve_history_account ( self ) -> ExtendedCurveHistoryAccount : res = await self . program . account [ \"CurveHistory\" ] . fetch ( self . pdas . curve_history ) return cast ( ExtendedCurveHistoryAccount , res ) async def get_extended_curve_history_account ( self ) -> ExtendedCurveHistoryAccount : res = await self . program . account [ \"ExtendedCurveHistory\" ] . fetch ( self . pdas . extended_curve_history ) return cast ( ExtendedCurveHistoryAccount , res ) async def get_orders_state_account ( self ) -> OrderState : res = await self . program . account [ \"OrderState\" ] . fetch ( self . pdas . order_state ) return cast ( OrderState , res ) async def get_orders_history_account ( self ) -> OrderHistoryAccount : order_state = await self . get_orders_state_account () res = await self . program . account [ \"OrderHistory\" ] . fetch ( order_state . order_history ) return cast ( OrderHistoryAccount , res ) @staticmethod def _get_state_pubkey ( program : Program ) -> PublicKey : return PublicKey . find_program_address ([ b \"clearing_house\" ], program . program_id )[ 0 ] @classmethod async def create ( cls : Type [ T ], program : Program ) -> T : \"\"\"Create a new `ClearingHouse` instance. Args: program: An AnchorPy Program instance. Returns: The new `ClearingHouse` instance. \"\"\" state_pubkey = cls . _get_state_pubkey ( program ) state = await _get_state_account ( program , state_pubkey ) pdas = ClearingHousePDAs ( state = state_pubkey , markets = state . markets , trade_history = state . trade_history , deposit_history = state . deposit_history , funding_payment_history = state . funding_payment_history , funding_rate_history = state . funding_rate_history , liquidation_history = state . liquidation_history , curve_history = state . curve_history , extended_curve_history = state . extended_curve_history , order_state = state . order_state , ) return cls ( program , pdas ) @classmethod async def create_from_env ( cls : Type [ T ], env : str ) -> T : \"\"\"Create a new `ClearingHouse` instance. Args: program: An AnchorPy Program instance. Returns: The new `ClearingHouse` instance. \"\"\" program = load_program ( env ) state_pubkey = cls . _get_state_pubkey ( program ) state = await _get_state_account ( program , state_pubkey ) pdas = ClearingHousePDAs ( state = state_pubkey , markets = state . markets , trade_history = state . trade_history , deposit_history = state . deposit_history , funding_payment_history = state . funding_payment_history , funding_rate_history = state . funding_rate_history , liquidation_history = state . liquidation_history , curve_history = state . curve_history , order_state = state . order_state , extended_curve_history = state . extended_curve_history , ) return cls ( program , pdas ) def get_initialize_user_instructions ( self , ) -> tuple [ Keypair , PublicKey , TransactionInstruction ]: user_public_key , user_account_nonce = get_user_account_public_key_and_nonce ( self . program . program_id , self . program . provider . wallet . public_key ) remaining_accounts : list [ AccountMeta ] = [] optional_accounts = self . program . type [ \"InitializeUserOptionalAccounts\" ]( whitelist_token = False ) user_positions = Keypair () initialize_user_account_ix = self . program . instruction [ \"initialize_user\" ]( user_account_nonce , optional_accounts , ctx = Context ( accounts = { \"user\" : user_public_key , \"authority\" : self . program . provider . wallet . public_key , \"rent\" : SYSVAR_RENT_PUBKEY , \"system_program\" : SYS_PROGRAM_ID , \"user_positions\" : user_positions . public_key , \"state\" : self . pdas . state , }, remaining_accounts = remaining_accounts , ), ) return user_positions , user_public_key , initialize_user_account_ix async def get_deposit_collateral_ix ( self , amount : int , collateral_account_public_key : PublicKey , user_positions_account_public_key : Optional [ PublicKey ] = None , state : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () if user_positions_account_public_key is None : user_account = await self . get_user_account () user_positions_account_public_key = user_account . positions state_to_use = await self . get_state_account () if state is None else state return self . program . instruction [ \"deposit_collateral\" ]( amount , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"collateral_vault\" : state_to_use . collateral_vault , \"user_collateral_account\" : collateral_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"token_program\" : TOKEN_PROGRAM_ID , \"markets\" : state_to_use . markets , \"funding_payment_history\" : state_to_use . funding_payment_history , \"deposit_history\" : state_to_use . deposit_history , \"user_positions\" : user_positions_account_public_key , }, ), ) async def deposit_collateral ( self , amount : int , collateral_account_public_key : PublicKey , user_positions_account_public_key : Optional [ PublicKey ] = None , state : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_deposit_collateral_ix ( amount , collateral_account_public_key , user_positions_account_public_key , state , ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def initialize_user_account_and_deposit_collateral ( self , amount : int , collateral_account_public_key : PublicKey , state : Optional [ StateAccount ] = None , ) -> tuple [ TransactionSignature , PublicKey ]: \"\"\"Creates the Clearing House User account for a user, and deposits some initial collateral.\"\"\" # noqa: E501 ( user_positions_account , user_account_public_key , initialize_user_account_ix , ) = self . get_initialize_user_instructions () deposit_collateral_ix = await self . get_deposit_collateral_ix ( amount , collateral_account_public_key , user_positions_account . public_key , state , ) tx = Transaction () . add ( initialize_user_account_ix , deposit_collateral_ix ) tx_sig = await self . program . provider . send ( tx , [ user_positions_account ]) return tx_sig , user_account_public_key def get_user_account_public_key ( self ) -> PublicKey : \"\"\"Get the address for the Clearing House User's account. NOT the user's wallet address. \"\"\" return get_user_account_public_key_and_nonce ( self . program . program_id , self . program . provider . wallet . public_key )[ 0 ] def get_user_orders_public_key ( self ) -> PublicKey : \"\"\"Get the address for the Clearing House User's order account. NOT the user's wallet address. \"\"\" return get_user_orders_account_public_key_and_nonce ( self . program . program_id , self . program . provider . wallet . public_key )[ 0 ] def get_order_state_public_key ( self ) -> PublicKey : \"\"\"Get the address for the Clearing House Order State account.\"\"\" return get_order_state_account_public_key_and_nonce ( self . program . program_id )[ 0 ] async def get_withdraw_collateral_ix ( self , amount : int , collateral_account_public_key : PublicKey , user_account : Optional [ User ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user = ( cast ( User , await self . program . account [ \"User\" ] . fetch ( user_account_public_key ) ) if user_account is None else user_account ) state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"withdraw_collateral\" ]( amount , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"collateral_vault\" : state . collateral_vault , \"collateral_vault_authority\" : state . collateral_vault_authority , \"insurance_vault\" : state . insurance_vault , \"insurance_vault_authority\" : state . insurance_vault_authority , \"user_collateral_account\" : collateral_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"token_program\" : TOKEN_PROGRAM_ID , \"markets\" : state . markets , \"user_positions\" : user . positions , \"funding_payment_history\" : state . funding_payment_history , \"deposit_history\" : state . deposit_history , }, ), ) async def withdraw_collateral ( self , amount : int , collateral_account_public_key : PublicKey , user : Optional [ User ] = None , state : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_withdraw_collateral_ix ( amount , collateral_account_public_key , user , state ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def open_position ( self , direction : PositionDirection , amount : int , market_index : int , limit_price : Optional [ int ] = None , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , ) -> TransactionSignature : ix = await self . get_open_position_ix ( direction , amount , market_index , limit_price , discount_token , referrer ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_open_position_ix ( self , direction : PositionDirection , amount : int , market_index : int , limit_price : Optional [ int ] = None , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) limit_price_to_use = 0 if limit_price is None else limit_price optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ market_index ] . amm . oracle state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"open_position\" ]( direction , amount , market_index , limit_price_to_use , optional_accounts , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_positions\" : user_account_to_use . positions , \"trade_history\" : state . trade_history , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), ) async def place_order ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , ) -> TransactionSignature : ix = await self . get_place_order_ix ( order_params , discount_token , referrer ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_place_order_ix ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , orders_state_account : Optional [ OrderState ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ order_params . market_index ] . amm . oracle state = ( await self . get_state_account () if state_account is None else state_account ) orders_state = ( await self . get_orders_state_account () if orders_state_account is None else orders_state_account ) return self . program . instruction [ \"place_order\" ]( order_params , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_orders\" : self . get_user_orders_public_key (), \"user_positions\" : user_account_to_use . positions , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"order_state\" : self . get_order_state_public_key (), \"order_history\" : orders_state . order_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), ) async def place_and_fill_order ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , ) -> TransactionSignature : ix = await self . get_place_and_fill_order_ix ( order_params , discount_token , referrer ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_place_and_fill_order_ix ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , orders_state_account : Optional [ OrderState ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ order_params . market_index ] . amm . oracle state = ( await self . get_state_account () if state_account is None else state_account ) orders_state = ( await self . get_orders_state_account () if orders_state_account is None else orders_state_account ) return self . program . instruction [ \"place_and_fill_order\" ]( order_params , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_orders\" : self . get_user_orders_public_key (), \"user_positions\" : user_account_to_use . positions , \"trade_history\" : state . trade_history , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"order_state\" : self . get_order_state_public_key (), \"order_history\" : orders_state . order_history , \"extended_curve_history\" : state . extended_curve_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), ) async def cancel_order ( self , order_id : int , ) -> TransactionSignature : ix = await self . get_cancel_order_ix ( order_id ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_cancel_order_ix ( self , order_id : int , user_account : Optional [ User ] = None , state_account : Optional [ StateAccount ] = None , orders_state_account : Optional [ OrderState ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) state = ( await self . get_state_account () if state_account is None else state_account ) orders_state = ( await self . get_orders_state_account () if orders_state_account is None else orders_state_account ) return self . program . instruction [ \"cancel_order\" ]( order_id , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_orders\" : self . get_user_orders_public_key (), \"user_positions\" : user_account_to_use . positions , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"order_state\" : self . get_order_state_public_key (), \"order_history\" : orders_state . order_history , }, ), ) async def get_user_account ( self ) -> User : user_account_pubkey = self . get_user_account_public_key () return cast ( User , await self . program . account [ \"User\" ] . fetch ( user_account_pubkey )) async def get_close_position_ix ( self , market_index : int , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ market_index ] . amm . oracle optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token is not None : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer is not None : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"close_position\" ]( market_index , optional_accounts , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_positions\" : user_account_to_use . positions , \"trade_history\" : state . trade_history , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), ) async def close_position ( self , market_index : int , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : \"\"\"Close an entire position. If you want to reduce a position, use the [open_position][driftpy.clearing_house.ClearingHouse.open_position] method in the opposite direction of the current position.\"\"\" # noqa: E501 ix = await self . get_close_position_ix ( market_index = market_index , discount_token = discount_token , referrer = referrer , user_account = user_account , markets_account = markets_account , state_account = state_account , ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def delete_user ( self ) -> TransactionSignature : user_account_public_key = self . get_user_account_public_key () user = await self . program . account [ \"User\" ] . fetch ( user_account_public_key ) return await self . program . rpc [ \"DeleteUser\" ]( ctx = Context ( accounts = { \"user\" : user_account_public_key , \"user_positions\" : user . positions , \"authority\" : self . program . provider . wallet . public_key , } ) ) async def liquidate ( self , liquidatee_user_account_public_key : PublicKey , liquidatee_user_account : Optional [ User ] = None , liquidatee_positions : Optional [ UserPositions ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_liquidate_ix ( liquidatee_user_account_public_key , liquidatee_user_account = liquidatee_user_account , liquidatee_positions = liquidatee_positions , markets_account = markets_account , state_account = state_account , ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_liquidate_ix ( self , liquidatee_user_account_public_key : PublicKey , liquidatee_user_account : Optional [ User ] = None , liquidatee_positions : Optional [ UserPositions ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () liquidatee_user_account_to_use = ( cast ( User , await self . program . account [ \"User\" ] . fetch ( liquidatee_user_account_public_key ), ) if liquidatee_user_account is None else liquidatee_user_account ) liquidatee_positions_to_use = ( cast ( UserPositions , await self . program . account [ \"UserPositions\" ] . fetch ( liquidatee_user_account_to_use . positions ), ) if liquidatee_positions is None else liquidatee_positions ) markets = ( await self . get_markets_account () if markets_account is None else markets_account ) remaining_accounts = [] for position in liquidatee_positions_to_use . positions : if position . base_asset_amount != 0 : market = markets . markets [ position . market_index ] remaining_accounts . append ( AccountMeta ( pubkey = market . amm . oracle , is_writable = False , is_signer = False , ) ) state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"liquidate\" ]( ctx = Context ( accounts = { \"state\" : self . pdas . state , \"authority\" : self . program . provider . wallet . public_key , \"user\" : liquidatee_user_account_public_key , \"liquidator\" : user_account_public_key , \"collateral_vault\" : state . collateral_vault , \"collateral_vault_authority\" : state . collateral_vault_authority , \"insurance_vault\" : state . insurance_vault , \"insurance_vault_authority\" : state . insurance_vault_authority , \"token_program\" : TOKEN_PROGRAM_ID , \"markets\" : state . markets , \"user_positions\" : liquidatee_user_account_to_use . positions , \"trade_history\" : state . trade_history , \"liquidation_history\" : state . liquidation_history , \"funding_payment_history\" : state . funding_payment_history , }, remaining_accounts = remaining_accounts , ) ) async def update_funding_rate ( self , oracle : PublicKey , market_index : int , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_update_funding_rate_ix ( oracle , market_index , state_account ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_update_funding_rate_ix ( self , oracle : PublicKey , market_index : int , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"update_funding_rate\" ]( market_index , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"markets\" : state . markets , \"oracle\" : oracle , \"funding_rate_history\" : state . funding_rate_history , }, ), ) async def settle_funding_payment ( self , user_account : PublicKey , user_positions_account : PublicKey , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_settle_funding_payment_ix ( user_account , user_positions_account ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx ) async def get_settle_funding_payment_ix ( self , user_account : PublicKey , user_positions_account : PublicKey , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"settle_funding_payment\" ]( ctx = Context ( accounts = { \"state\" : self . pdas . state , \"markets\" : state . markets , \"user\" : user_account , \"user_positions\" : user_positions_account , \"funding_payment_history\" : state . funding_payment_history , }, ) ) @staticmethod def local_idl () -> Idl : \"\"\"Load the `clearing_house` IDL embedded in the Python package.\"\"\" with resources . open_text ( \"driftpy.idl\" , \"clearing_house.json\" ) as f : idl_raw = json . load ( f ) return Idl . from_json ( idl_raw )","title":"ClearingHouse"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.__init__","text":"Initialize the ClearingHouse object. Note: you probably want to use create instead of this method. Parameters: Name Type Description Default program Program The AnchorPy program object. required pdas ClearingHousePDAs The required PDAs for the ClearingHouse object. required Source code in driftpy/clearing_house.py def __init__ ( self , program : Program , pdas : ClearingHousePDAs ): \"\"\"Initialize the ClearingHouse object. Note: you probably want to use [create][driftpy.clearing_house.ClearingHouse.create] instead of this method. Args: program: The AnchorPy program object. pdas: The required PDAs for the ClearingHouse object. \"\"\" self . program = program self . pdas = pdas","title":"__init__()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.cancel_order","text":"Source code in driftpy/clearing_house.py async def cancel_order ( self , order_id : int , ) -> TransactionSignature : ix = await self . get_cancel_order_ix ( order_id ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx )","title":"cancel_order()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.close_position","text":"Close an entire position. If you want to reduce a position, use the open_position method in the opposite direction of the current position. Source code in driftpy/clearing_house.py async def close_position ( self , market_index : int , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : \"\"\"Close an entire position. If you want to reduce a position, use the [open_position][driftpy.clearing_house.ClearingHouse.open_position] method in the opposite direction of the current position.\"\"\" # noqa: E501 ix = await self . get_close_position_ix ( market_index = market_index , discount_token = discount_token , referrer = referrer , user_account = user_account , markets_account = markets_account , state_account = state_account , ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx )","title":"close_position()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.create","text":"Create a new ClearingHouse instance. Parameters: Name Type Description Default program Program An AnchorPy Program instance. required Returns: Type Description ~T The new ClearingHouse instance. Source code in driftpy/clearing_house.py @classmethod async def create ( cls : Type [ T ], program : Program ) -> T : \"\"\"Create a new `ClearingHouse` instance. Args: program: An AnchorPy Program instance. Returns: The new `ClearingHouse` instance. \"\"\" state_pubkey = cls . _get_state_pubkey ( program ) state = await _get_state_account ( program , state_pubkey ) pdas = ClearingHousePDAs ( state = state_pubkey , markets = state . markets , trade_history = state . trade_history , deposit_history = state . deposit_history , funding_payment_history = state . funding_payment_history , funding_rate_history = state . funding_rate_history , liquidation_history = state . liquidation_history , curve_history = state . curve_history , extended_curve_history = state . extended_curve_history , order_state = state . order_state , ) return cls ( program , pdas )","title":"create()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.create_from_env","text":"Create a new ClearingHouse instance. Parameters: Name Type Description Default program An AnchorPy Program instance. required Returns: Type Description ~T The new ClearingHouse instance. Source code in driftpy/clearing_house.py @classmethod async def create_from_env ( cls : Type [ T ], env : str ) -> T : \"\"\"Create a new `ClearingHouse` instance. Args: program: An AnchorPy Program instance. Returns: The new `ClearingHouse` instance. \"\"\" program = load_program ( env ) state_pubkey = cls . _get_state_pubkey ( program ) state = await _get_state_account ( program , state_pubkey ) pdas = ClearingHousePDAs ( state = state_pubkey , markets = state . markets , trade_history = state . trade_history , deposit_history = state . deposit_history , funding_payment_history = state . funding_payment_history , funding_rate_history = state . funding_rate_history , liquidation_history = state . liquidation_history , curve_history = state . curve_history , order_state = state . order_state , extended_curve_history = state . extended_curve_history , ) return cls ( program , pdas )","title":"create_from_env()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.delete_user","text":"Source code in driftpy/clearing_house.py async def delete_user ( self ) -> TransactionSignature : user_account_public_key = self . get_user_account_public_key () user = await self . program . account [ \"User\" ] . fetch ( user_account_public_key ) return await self . program . rpc [ \"DeleteUser\" ]( ctx = Context ( accounts = { \"user\" : user_account_public_key , \"user_positions\" : user . positions , \"authority\" : self . program . provider . wallet . public_key , } ) )","title":"delete_user()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.deposit_collateral","text":"Source code in driftpy/clearing_house.py async def deposit_collateral ( self , amount : int , collateral_account_public_key : PublicKey , user_positions_account_public_key : Optional [ PublicKey ] = None , state : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_deposit_collateral_ix ( amount , collateral_account_public_key , user_positions_account_public_key , state , ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx )","title":"deposit_collateral()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_cancel_order_ix","text":"Source code in driftpy/clearing_house.py async def get_cancel_order_ix ( self , order_id : int , user_account : Optional [ User ] = None , state_account : Optional [ StateAccount ] = None , orders_state_account : Optional [ OrderState ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) state = ( await self . get_state_account () if state_account is None else state_account ) orders_state = ( await self . get_orders_state_account () if orders_state_account is None else orders_state_account ) return self . program . instruction [ \"cancel_order\" ]( order_id , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_orders\" : self . get_user_orders_public_key (), \"user_positions\" : user_account_to_use . positions , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"order_state\" : self . get_order_state_public_key (), \"order_history\" : orders_state . order_history , }, ), )","title":"get_cancel_order_ix()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_close_position_ix","text":"Source code in driftpy/clearing_house.py async def get_close_position_ix ( self , market_index : int , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ market_index ] . amm . oracle optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token is not None : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer is not None : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"close_position\" ]( market_index , optional_accounts , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_positions\" : user_account_to_use . positions , \"trade_history\" : state . trade_history , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), )","title":"get_close_position_ix()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_curve_history_account","text":"Source code in driftpy/clearing_house.py async def get_curve_history_account ( self ) -> ExtendedCurveHistoryAccount : res = await self . program . account [ \"CurveHistory\" ] . fetch ( self . pdas . curve_history ) return cast ( ExtendedCurveHistoryAccount , res )","title":"get_curve_history_account()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_deposit_collateral_ix","text":"Source code in driftpy/clearing_house.py async def get_deposit_collateral_ix ( self , amount : int , collateral_account_public_key : PublicKey , user_positions_account_public_key : Optional [ PublicKey ] = None , state : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () if user_positions_account_public_key is None : user_account = await self . get_user_account () user_positions_account_public_key = user_account . positions state_to_use = await self . get_state_account () if state is None else state return self . program . instruction [ \"deposit_collateral\" ]( amount , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"collateral_vault\" : state_to_use . collateral_vault , \"user_collateral_account\" : collateral_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"token_program\" : TOKEN_PROGRAM_ID , \"markets\" : state_to_use . markets , \"funding_payment_history\" : state_to_use . funding_payment_history , \"deposit_history\" : state_to_use . deposit_history , \"user_positions\" : user_positions_account_public_key , }, ), )","title":"get_deposit_collateral_ix()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_deposit_history_account","text":"Source code in driftpy/clearing_house.py async def get_deposit_history_account ( self ) -> DepositHistoryAccount : res = await self . program . account [ \"DepositHistory\" ] . fetch ( self . pdas . deposit_history ) return cast ( DepositHistoryAccount , res )","title":"get_deposit_history_account()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_extended_curve_history_account","text":"Source code in driftpy/clearing_house.py async def get_extended_curve_history_account ( self ) -> ExtendedCurveHistoryAccount : res = await self . program . account [ \"ExtendedCurveHistory\" ] . fetch ( self . pdas . extended_curve_history ) return cast ( ExtendedCurveHistoryAccount , res )","title":"get_extended_curve_history_account()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_funding_payment_history_account","text":"Source code in driftpy/clearing_house.py async def get_funding_payment_history_account ( self ) -> FundingPaymentHistoryAccount : res = await self . program . account [ \"FundingPaymentHistory\" ] . fetch ( self . pdas . funding_payment_history ) return cast ( FundingPaymentHistoryAccount , res )","title":"get_funding_payment_history_account()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_funding_rate_history_account","text":"Source code in driftpy/clearing_house.py async def get_funding_rate_history_account ( self ) -> FundingRateHistoryAccount : res = await self . program . account [ \"FundingRateHistory\" ] . fetch ( self . pdas . funding_rate_history ) return cast ( FundingRateHistoryAccount , res )","title":"get_funding_rate_history_account()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_initialize_user_instructions","text":"Source code in driftpy/clearing_house.py def get_initialize_user_instructions ( self , ) -> tuple [ Keypair , PublicKey , TransactionInstruction ]: user_public_key , user_account_nonce = get_user_account_public_key_and_nonce ( self . program . program_id , self . program . provider . wallet . public_key ) remaining_accounts : list [ AccountMeta ] = [] optional_accounts = self . program . type [ \"InitializeUserOptionalAccounts\" ]( whitelist_token = False ) user_positions = Keypair () initialize_user_account_ix = self . program . instruction [ \"initialize_user\" ]( user_account_nonce , optional_accounts , ctx = Context ( accounts = { \"user\" : user_public_key , \"authority\" : self . program . provider . wallet . public_key , \"rent\" : SYSVAR_RENT_PUBKEY , \"system_program\" : SYS_PROGRAM_ID , \"user_positions\" : user_positions . public_key , \"state\" : self . pdas . state , }, remaining_accounts = remaining_accounts , ), ) return user_positions , user_public_key , initialize_user_account_ix","title":"get_initialize_user_instructions()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_liquidate_ix","text":"Source code in driftpy/clearing_house.py async def get_liquidate_ix ( self , liquidatee_user_account_public_key : PublicKey , liquidatee_user_account : Optional [ User ] = None , liquidatee_positions : Optional [ UserPositions ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () liquidatee_user_account_to_use = ( cast ( User , await self . program . account [ \"User\" ] . fetch ( liquidatee_user_account_public_key ), ) if liquidatee_user_account is None else liquidatee_user_account ) liquidatee_positions_to_use = ( cast ( UserPositions , await self . program . account [ \"UserPositions\" ] . fetch ( liquidatee_user_account_to_use . positions ), ) if liquidatee_positions is None else liquidatee_positions ) markets = ( await self . get_markets_account () if markets_account is None else markets_account ) remaining_accounts = [] for position in liquidatee_positions_to_use . positions : if position . base_asset_amount != 0 : market = markets . markets [ position . market_index ] remaining_accounts . append ( AccountMeta ( pubkey = market . amm . oracle , is_writable = False , is_signer = False , ) ) state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"liquidate\" ]( ctx = Context ( accounts = { \"state\" : self . pdas . state , \"authority\" : self . program . provider . wallet . public_key , \"user\" : liquidatee_user_account_public_key , \"liquidator\" : user_account_public_key , \"collateral_vault\" : state . collateral_vault , \"collateral_vault_authority\" : state . collateral_vault_authority , \"insurance_vault\" : state . insurance_vault , \"insurance_vault_authority\" : state . insurance_vault_authority , \"token_program\" : TOKEN_PROGRAM_ID , \"markets\" : state . markets , \"user_positions\" : liquidatee_user_account_to_use . positions , \"trade_history\" : state . trade_history , \"liquidation_history\" : state . liquidation_history , \"funding_payment_history\" : state . funding_payment_history , }, remaining_accounts = remaining_accounts , ) )","title":"get_liquidate_ix()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_liquidation_history_account","text":"Source code in driftpy/clearing_house.py async def get_liquidation_history_account ( self ) -> LiquidationHistoryAccount : res = await self . program . account [ \"LiquidationHistory\" ] . fetch ( self . pdas . liquidation_history ) return cast ( LiquidationHistoryAccount , res )","title":"get_liquidation_history_account()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_market","text":"Source code in driftpy/clearing_house.py async def get_market ( self , market_index ) -> Market : market = ( await self . get_markets_account ()) . markets [ market_index ] return cast ( Market , market )","title":"get_market()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_markets_account","text":"Source code in driftpy/clearing_house.py async def get_markets_account ( self ) -> MarketsAccount : res = await self . program . account [ \"Markets\" ] . fetch ( self . pdas . markets ) return cast ( MarketsAccount , res )","title":"get_markets_account()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_open_position_ix","text":"Source code in driftpy/clearing_house.py async def get_open_position_ix ( self , direction : PositionDirection , amount : int , market_index : int , limit_price : Optional [ int ] = None , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) limit_price_to_use = 0 if limit_price is None else limit_price optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ market_index ] . amm . oracle state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"open_position\" ]( direction , amount , market_index , limit_price_to_use , optional_accounts , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_positions\" : user_account_to_use . positions , \"trade_history\" : state . trade_history , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), )","title":"get_open_position_ix()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_order_state_public_key","text":"Get the address for the Clearing House Order State account. Source code in driftpy/clearing_house.py def get_order_state_public_key ( self ) -> PublicKey : \"\"\"Get the address for the Clearing House Order State account.\"\"\" return get_order_state_account_public_key_and_nonce ( self . program . program_id )[ 0 ]","title":"get_order_state_public_key()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_orders_history_account","text":"Source code in driftpy/clearing_house.py async def get_orders_history_account ( self ) -> OrderHistoryAccount : order_state = await self . get_orders_state_account () res = await self . program . account [ \"OrderHistory\" ] . fetch ( order_state . order_history ) return cast ( OrderHistoryAccount , res )","title":"get_orders_history_account()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_orders_state_account","text":"Source code in driftpy/clearing_house.py async def get_orders_state_account ( self ) -> OrderState : res = await self . program . account [ \"OrderState\" ] . fetch ( self . pdas . order_state ) return cast ( OrderState , res )","title":"get_orders_state_account()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_place_and_fill_order_ix","text":"Source code in driftpy/clearing_house.py async def get_place_and_fill_order_ix ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , orders_state_account : Optional [ OrderState ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ order_params . market_index ] . amm . oracle state = ( await self . get_state_account () if state_account is None else state_account ) orders_state = ( await self . get_orders_state_account () if orders_state_account is None else orders_state_account ) return self . program . instruction [ \"place_and_fill_order\" ]( order_params , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_orders\" : self . get_user_orders_public_key (), \"user_positions\" : user_account_to_use . positions , \"trade_history\" : state . trade_history , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"order_state\" : self . get_order_state_public_key (), \"order_history\" : orders_state . order_history , \"extended_curve_history\" : state . extended_curve_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), )","title":"get_place_and_fill_order_ix()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_place_order_ix","text":"Source code in driftpy/clearing_house.py async def get_place_order_ix ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , user_account : Optional [ User ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , orders_state_account : Optional [ OrderState ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user_account_to_use = ( await self . get_user_account () if user_account is None else user_account ) optional_accounts = { \"discount_token\" : False , \"referrer\" : False , } remaining_accounts = [] if discount_token : optional_accounts [ \"discount_token\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = discount_token , is_writable = False , is_signer = False , ) ) if referrer : optional_accounts [ \"referrer\" ] = True remaining_accounts . append ( AccountMeta ( pubkey = referrer , is_writable = True , is_signer = False , ) ) markets_account_to_use = ( await self . get_markets_account () if markets_account is None else markets_account ) price_oracle = markets_account_to_use . markets [ order_params . market_index ] . amm . oracle state = ( await self . get_state_account () if state_account is None else state_account ) orders_state = ( await self . get_orders_state_account () if orders_state_account is None else orders_state_account ) return self . program . instruction [ \"place_order\" ]( order_params , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"markets\" : state . markets , \"user_orders\" : self . get_user_orders_public_key (), \"user_positions\" : user_account_to_use . positions , \"funding_payment_history\" : state . funding_payment_history , \"funding_rate_history\" : state . funding_rate_history , \"order_state\" : self . get_order_state_public_key (), \"order_history\" : orders_state . order_history , \"oracle\" : price_oracle , }, remaining_accounts = remaining_accounts , ), )","title":"get_place_order_ix()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_settle_funding_payment_ix","text":"Source code in driftpy/clearing_house.py async def get_settle_funding_payment_ix ( self , user_account : PublicKey , user_positions_account : PublicKey , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"settle_funding_payment\" ]( ctx = Context ( accounts = { \"state\" : self . pdas . state , \"markets\" : state . markets , \"user\" : user_account , \"user_positions\" : user_positions_account , \"funding_payment_history\" : state . funding_payment_history , }, ) )","title":"get_settle_funding_payment_ix()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_state_account","text":"Source code in driftpy/clearing_house.py async def get_state_account ( self ) -> StateAccount : res = await _get_state_account ( self . program , self . pdas . state ) return cast ( StateAccount , res )","title":"get_state_account()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_trade_history_account","text":"Source code in driftpy/clearing_house.py async def get_trade_history_account ( self ) -> TradeHistoryAccount : res = await self . program . account [ \"TradeHistory\" ] . fetch ( self . pdas . trade_history ) return cast ( TradeHistoryAccount , res )","title":"get_trade_history_account()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_update_funding_rate_ix","text":"Source code in driftpy/clearing_house.py async def get_update_funding_rate_ix ( self , oracle : PublicKey , market_index : int , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"update_funding_rate\" ]( market_index , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"markets\" : state . markets , \"oracle\" : oracle , \"funding_rate_history\" : state . funding_rate_history , }, ), )","title":"get_update_funding_rate_ix()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_user_account","text":"Source code in driftpy/clearing_house.py async def get_user_account ( self ) -> User : user_account_pubkey = self . get_user_account_public_key () return cast ( User , await self . program . account [ \"User\" ] . fetch ( user_account_pubkey ))","title":"get_user_account()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_user_account_public_key","text":"Get the address for the Clearing House User's account. NOT the user's wallet address. Source code in driftpy/clearing_house.py def get_user_account_public_key ( self ) -> PublicKey : \"\"\"Get the address for the Clearing House User's account. NOT the user's wallet address. \"\"\" return get_user_account_public_key_and_nonce ( self . program . program_id , self . program . provider . wallet . public_key )[ 0 ]","title":"get_user_account_public_key()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_user_orders_public_key","text":"Get the address for the Clearing House User's order account. NOT the user's wallet address. Source code in driftpy/clearing_house.py def get_user_orders_public_key ( self ) -> PublicKey : \"\"\"Get the address for the Clearing House User's order account. NOT the user's wallet address. \"\"\" return get_user_orders_account_public_key_and_nonce ( self . program . program_id , self . program . provider . wallet . public_key )[ 0 ]","title":"get_user_orders_public_key()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.get_withdraw_collateral_ix","text":"Source code in driftpy/clearing_house.py async def get_withdraw_collateral_ix ( self , amount : int , collateral_account_public_key : PublicKey , user_account : Optional [ User ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionInstruction : user_account_public_key = self . get_user_account_public_key () user = ( cast ( User , await self . program . account [ \"User\" ] . fetch ( user_account_public_key ) ) if user_account is None else user_account ) state = ( await self . get_state_account () if state_account is None else state_account ) return self . program . instruction [ \"withdraw_collateral\" ]( amount , ctx = Context ( accounts = { \"state\" : self . pdas . state , \"user\" : user_account_public_key , \"collateral_vault\" : state . collateral_vault , \"collateral_vault_authority\" : state . collateral_vault_authority , \"insurance_vault\" : state . insurance_vault , \"insurance_vault_authority\" : state . insurance_vault_authority , \"user_collateral_account\" : collateral_account_public_key , \"authority\" : self . program . provider . wallet . public_key , \"token_program\" : TOKEN_PROGRAM_ID , \"markets\" : state . markets , \"user_positions\" : user . positions , \"funding_payment_history\" : state . funding_payment_history , \"deposit_history\" : state . deposit_history , }, ), )","title":"get_withdraw_collateral_ix()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.initialize_user_account_and_deposit_collateral","text":"Creates the Clearing House User account for a user, and deposits some initial collateral. Source code in driftpy/clearing_house.py async def initialize_user_account_and_deposit_collateral ( self , amount : int , collateral_account_public_key : PublicKey , state : Optional [ StateAccount ] = None , ) -> tuple [ TransactionSignature , PublicKey ]: \"\"\"Creates the Clearing House User account for a user, and deposits some initial collateral.\"\"\" # noqa: E501 ( user_positions_account , user_account_public_key , initialize_user_account_ix , ) = self . get_initialize_user_instructions () deposit_collateral_ix = await self . get_deposit_collateral_ix ( amount , collateral_account_public_key , user_positions_account . public_key , state , ) tx = Transaction () . add ( initialize_user_account_ix , deposit_collateral_ix ) tx_sig = await self . program . provider . send ( tx , [ user_positions_account ]) return tx_sig , user_account_public_key","title":"initialize_user_account_and_deposit_collateral()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.liquidate","text":"Source code in driftpy/clearing_house.py async def liquidate ( self , liquidatee_user_account_public_key : PublicKey , liquidatee_user_account : Optional [ User ] = None , liquidatee_positions : Optional [ UserPositions ] = None , markets_account : Optional [ MarketsAccount ] = None , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_liquidate_ix ( liquidatee_user_account_public_key , liquidatee_user_account = liquidatee_user_account , liquidatee_positions = liquidatee_positions , markets_account = markets_account , state_account = state_account , ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx )","title":"liquidate()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.local_idl","text":"Load the clearing_house IDL embedded in the Python package. Source code in driftpy/clearing_house.py @staticmethod def local_idl () -> Idl : \"\"\"Load the `clearing_house` IDL embedded in the Python package.\"\"\" with resources . open_text ( \"driftpy.idl\" , \"clearing_house.json\" ) as f : idl_raw = json . load ( f ) return Idl . from_json ( idl_raw )","title":"local_idl()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.open_position","text":"Source code in driftpy/clearing_house.py async def open_position ( self , direction : PositionDirection , amount : int , market_index : int , limit_price : Optional [ int ] = None , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , ) -> TransactionSignature : ix = await self . get_open_position_ix ( direction , amount , market_index , limit_price , discount_token , referrer ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx )","title":"open_position()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.place_and_fill_order","text":"Source code in driftpy/clearing_house.py async def place_and_fill_order ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , ) -> TransactionSignature : ix = await self . get_place_and_fill_order_ix ( order_params , discount_token , referrer ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx )","title":"place_and_fill_order()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.place_order","text":"Source code in driftpy/clearing_house.py async def place_order ( self , order_params : OrderParams , discount_token : Optional [ PublicKey ] = None , referrer : Optional [ PublicKey ] = None , ) -> TransactionSignature : ix = await self . get_place_order_ix ( order_params , discount_token , referrer ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx )","title":"place_order()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.settle_funding_payment","text":"Source code in driftpy/clearing_house.py async def settle_funding_payment ( self , user_account : PublicKey , user_positions_account : PublicKey , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_settle_funding_payment_ix ( user_account , user_positions_account ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx )","title":"settle_funding_payment()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.update_funding_rate","text":"Source code in driftpy/clearing_house.py async def update_funding_rate ( self , oracle : PublicKey , market_index : int , state_account : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_update_funding_rate_ix ( oracle , market_index , state_account ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx )","title":"update_funding_rate()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHouse.withdraw_collateral","text":"Source code in driftpy/clearing_house.py async def withdraw_collateral ( self , amount : int , collateral_account_public_key : PublicKey , user : Optional [ User ] = None , state : Optional [ StateAccount ] = None , ) -> TransactionSignature : ix = await self . get_withdraw_collateral_ix ( amount , collateral_account_public_key , user , state ) tx = Transaction () . add ( ix ) return await self . program . provider . send ( tx )","title":"withdraw_collateral()"},{"location":"api_reference/#driftpy.clearing_house.ClearingHousePDAs","text":"A collection of pubkeys needed to instantiate ClearingHouse Source code in driftpy/clearing_house.py @dataclass class ClearingHousePDAs : \"\"\"A collection of pubkeys needed to instantiate [ClearingHouse][driftpy.clearing_house.ClearingHouse]\"\"\" state : PublicKey markets : PublicKey trade_history : PublicKey deposit_history : PublicKey funding_payment_history : PublicKey funding_rate_history : PublicKey liquidation_history : PublicKey curve_history : PublicKey extended_curve_history : PublicKey order_state : PublicKey","title":"ClearingHousePDAs"},{"location":"api_reference/#driftpy.clearing_house.ClearingHousePDAs.curve_history","text":"","title":"curve_history"},{"location":"api_reference/#driftpy.clearing_house.ClearingHousePDAs.deposit_history","text":"","title":"deposit_history"},{"location":"api_reference/#driftpy.clearing_house.ClearingHousePDAs.extended_curve_history","text":"","title":"extended_curve_history"},{"location":"api_reference/#driftpy.clearing_house.ClearingHousePDAs.funding_payment_history","text":"","title":"funding_payment_history"},{"location":"api_reference/#driftpy.clearing_house.ClearingHousePDAs.funding_rate_history","text":"","title":"funding_rate_history"},{"location":"api_reference/#driftpy.clearing_house.ClearingHousePDAs.liquidation_history","text":"","title":"liquidation_history"},{"location":"api_reference/#driftpy.clearing_house.ClearingHousePDAs.markets","text":"","title":"markets"},{"location":"api_reference/#driftpy.clearing_house.ClearingHousePDAs.order_state","text":"","title":"order_state"},{"location":"api_reference/#driftpy.clearing_house.ClearingHousePDAs.state","text":"","title":"state"},{"location":"api_reference/#driftpy.clearing_house.ClearingHousePDAs.trade_history","text":"","title":"trade_history"},{"location":"api_reference/#driftpy.clearing_house.ClearingHousePDAs.__init__","text":"","title":"__init__()"}]}